WORKFLOW
- user runs xweb
 > it traverses all HTML files recursively, identifying HTML section, header and footer elements ('sections')
 > builds a global list of sections, storing hash, id and node pointer
 > a "data-xweb" hash attrbute is added to each section (id and hash are skipped during hash calculation)

- if --reformat was used:
 > sections with same hash are updated with the same id
 > sections with different hash but same id are given unique id

- if not:
 > sections with same id are iterated
 > if more than one has been updated (new hash != old hash), ask used which section to use
 > update all sections with the chosen section

 > a list of sections ids is shown across all files
 > all HTML files are rewritten

IMPLEMENTATION
- per-file struct has:
 > file pointer
 > html tree
 > updated flag

- per-section struct has:
 > id
 > highest revision
 > list of html nodes to replace
 > pointer to per-file struct to set writeback flag

- for each html file found via filepath.Walk:
 > use golang.org/x/net/html [updating via file, err := os.OpenFile("sample.html", os.O_RDWR | os.O_TRUNC, 0644); html.Render(file, doc)]
 > create per-file datastructure
 > for each "section" element, stored by id
   > if a "data-xdeb" attribute present, store revision if higher
   > if multiple highest revisions, error out

- for each per-section struct:
 > if highest revision is 0, skip
 > iterate HTML node list, performing deep copy, preseving attributes eg class
 > set linked per-file writeback flag

- for each file struct:
 > if writeback set, rerender to file

TODO
- initial setup mode
 > parse all files, looking for section HTML element
   - remove id attribute
   - perform deep hash
   - store in map by hash, including id
